import { Architecture } from '../types';

/**
 * Google-inspired system architecture example
 * Based on a typical search service architecture pattern
 */
export const createDemoArchitecture = (userId: string = 'demo-user'): Architecture => ({
  id: 'demo-search-system',
  name: 'Global Search Service Architecture',
  description: 'A distributed search system architecture inspired by large-scale web services',
  problemStatement: 'Build a highly available, low-latency search service that can handle millions of queries per second while maintaining data consistency and fault tolerance',
  constraints: [
    'Query latency must be < 100ms at p99',
    'System must handle 10M+ queries per second',
    'Data must be geo-replicated across 3+ regions',
    '99.99% uptime SLA'
  ],
  assumptions: [
    'Users are distributed globally',
    'Data can be eventually consistent',
    'Index updates can have up to 60s delay',
    'Network between data centers is reliable'
  ],
  nonGoals: [
    'Real-time personalized results (handled by separate service)',
    'Ad serving (handled by separate service)',
    'Analytics and logging (uses centralized platform)'
  ],
  knownFailureScenarios: [
    'Regional data center outage',
    'Index corruption during update',
    'Cache stampede during cold start',
    'Network partition between regions'
  ],
  components: [
    {
      id: 'frontend-lb',
      name: 'Global Load Balancer',
      type: 'API',
      responsibility: 'Route user queries to nearest regional endpoint, health checks, DDoS protection',
      inputs: ['User search queries (HTTPS)'],
      outputs: ['Routed requests to regional servers'],
      dependencies: ['regional-api-us', 'regional-api-eu', 'regional-api-asia'],
      owner: 'Infrastructure Team',
      environment: 'prod',
      criticality: 'high',
      failureModes: [
        {
          id: 'fm-glb-1',
          description: 'DNS resolution failure',
          impact: 'Users cannot reach service',
          probability: 'low',
        },
        {
          id: 'fm-glb-2',
          description: 'Routing logic error',
          impact: 'Suboptimal routing increases latency',
          probability: 'medium',
        }
      ],
      recoveryStrategy: [
        {
          id: 'rs-glb-1',
          description: 'Automatic failover to backup DNS provider',
          automaticRetry: true,
          manualIntervention: false,
          estimatedRecoveryTime: '30 seconds',
        }
      ],
      notes: 'Uses Anycast IP with GeoDNS for optimal routing',
      assumptions: ['Multiple DNS providers for redundancy'],
      position: { x: 600, y: 100 },
    },
    {
      id: 'regional-api-us',
      name: 'US Regional API',
      type: 'API',
      responsibility: 'Handle search queries, query parsing, result ranking',
      inputs: ['Search queries'],
      outputs: ['Ranked search results'],
      dependencies: ['cache-us', 'index-us'],
      owner: 'Search Team',
      environment: 'prod',
      criticality: 'high',
      failureModes: [
        {
          id: 'fm-api-1',
          description: 'Service overload',
          impact: 'Increased latency or dropped requests',
          probability: 'medium',
        }
      ],
      recoveryStrategy: [
        {
          id: 'rs-api-1',
          description: 'Auto-scale to 200% capacity within 60s',
          automaticRetry: true,
          manualIntervention: false,
          estimatedRecoveryTime: '1 minute',
        }
      ],
      notes: 'Stateless service running on Kubernetes across 3 availability zones',
      assumptions: ['Load is distributed evenly across AZs'],
      position: { x: 100, y: 350 },
    },
    {
      id: 'regional-api-eu',
      name: 'EU Regional API',
      type: 'API',
      responsibility: 'Handle search queries, query parsing, result ranking',
      inputs: ['Search queries'],
      outputs: ['Ranked search results'],
      dependencies: ['cache-eu', 'index-eu'],
      owner: 'Search Team',
      environment: 'prod',
      criticality: 'high',
      failureModes: [],
      recoveryStrategy: [],
      notes: 'Stateless service running on Kubernetes across 3 availability zones',
      assumptions: ['Load is distributed evenly across AZs'],
      position: { x: 600, y: 350 },
    },
    {
      id: 'regional-api-asia',
      name: 'Asia Regional API',
      type: 'API',
      responsibility: 'Handle search queries, query parsing, result ranking',
      inputs: ['Search queries'],
      outputs: ['Ranked search results'],
      dependencies: ['cache-asia', 'index-asia'],
      owner: 'Search Team',
      environment: 'prod',
      criticality: 'high',
      failureModes: [],
      recoveryStrategy: [],
      notes: 'Stateless service running on Kubernetes across 3 availability zones',
      assumptions: ['Load is distributed evenly across AZs'],
      position: { x: 1100, y: 350 },
    },
    {
      id: 'cache-us',
      name: 'US Cache Cluster',
      type: 'DB',
      responsibility: 'Cache frequent queries and results to reduce latency',
      inputs: ['Cache keys (query hashes)'],
      outputs: ['Cached results or miss'],
      dependencies: [],
      owner: 'Infrastructure Team',
      environment: 'prod',
      criticality: 'medium',
      failureModes: [
        {
          id: 'fm-cache-1',
          description: 'Cache node failure',
          impact: 'Slight increase in latency, more load on index',
          probability: 'low',
        }
      ],
      recoveryStrategy: [
        {
          id: 'rs-cache-1',
          description: 'Remaining nodes handle load, new node auto-provisions',
          automaticRetry: true,
          manualIntervention: false,
          estimatedRecoveryTime: '5 minutes',
        }
      ],
      notes: 'Redis cluster with 20+ nodes, consistent hashing',
      assumptions: ['80% cache hit rate'],
      position: { x: 100, y: 600 },
    },
    {
      id: 'cache-eu',
      name: 'EU Cache Cluster',
      type: 'DB',
      responsibility: 'Cache frequent queries and results',
      inputs: ['Cache keys (query hashes)'],
      outputs: ['Cached results or miss'],
      dependencies: [],
      owner: 'Infrastructure Team',
      environment: 'prod',
      criticality: 'medium',
      failureModes: [],
      recoveryStrategy: [],
      notes: 'Redis cluster with 20+ nodes, consistent hashing',
      assumptions: ['80% cache hit rate'],
      position: { x: 600, y: 600 },
    },
    {
      id: 'cache-asia',
      name: 'Asia Cache Cluster',
      type: 'DB',
      responsibility: 'Cache frequent queries and results',
      inputs: ['Cache keys (query hashes)'],
      outputs: ['Cached results or miss'],
      dependencies: [],
      owner: 'Infrastructure Team',
      environment: 'prod',
      criticality: 'medium',
      failureModes: [],
      recoveryStrategy: [],
      notes: 'Redis cluster with 20+ nodes, consistent hashing',
      assumptions: ['80% cache hit rate'],
      position: { x: 1100, y: 600 },
    },
    {
      id: 'index-us',
      name: 'US Search Index',
      type: 'DB',
      responsibility: 'Inverted index for full-text search, stores document metadata',
      inputs: ['Search queries'],
      outputs: ['Matching document IDs and scores'],
      dependencies: [],
      owner: 'Search Team',
      environment: 'prod',
      criticality: 'high',
      failureModes: [
        {
          id: 'fm-index-1',
          description: 'Shard failure',
          impact: 'Partial results for some queries',
          probability: 'low',
        }
      ],
      recoveryStrategy: [
        {
          id: 'rs-index-1',
          description: 'Rebuild shard from replica',
          automaticRetry: true,
          manualIntervention: false,
          estimatedRecoveryTime: '10 minutes',
        }
      ],
      notes: 'Distributed index across 100+ shards with 3x replication',
      assumptions: ['Indices are updated every 60 seconds'],
      position: { x: 100, y: 850 },
    },
    {
      id: 'index-eu',
      name: 'EU Search Index',
      type: 'DB',
      responsibility: 'Inverted index for full-text search',
      inputs: ['Search queries'],
      outputs: ['Matching document IDs and scores'],
      dependencies: [],
      owner: 'Search Team',
      environment: 'prod',
      criticality: 'high',
      failureModes: [],
      recoveryStrategy: [],
      notes: 'Distributed index across 100+ shards with 3x replication',
      assumptions: ['Indices are updated every 60 seconds'],
      position: { x: 600, y: 850 },
    },
    {
      id: 'index-asia',
      name: 'Asia Search Index',
      type: 'DB',
      responsibility: 'Inverted index for full-text search',
      inputs: ['Search queries'],
      outputs: ['Matching document IDs and scores'],
      dependencies: [],
      owner: 'Search Team',
      environment: 'prod',
      criticality: 'high',
      failureModes: [],
      recoveryStrategy: [],
      notes: 'Distributed index across 100+ shards with 3x replication',
      assumptions: ['Indices are updated every 60 seconds'],
      position: { x: 1100, y: 850 },
    },
    {
      id: 'indexer',
      name: 'Index Builder',
      type: 'Worker',
      responsibility: 'Process document updates, build and distribute search indices',
      inputs: ['Document update events from queue'],
      outputs: ['Updated indices pushed to all regions'],
      dependencies: ['update-queue', 'index-us', 'index-eu', 'index-asia'],
      owner: 'Search Team',
      environment: 'prod',
      criticality: 'medium',
      failureModes: [
        {
          id: 'fm-indexer-1',
          description: 'Index build failure',
          impact: 'Stale search results until next build',
          probability: 'low',
        }
      ],
      recoveryStrategy: [
        {
          id: 'rs-indexer-1',
          description: 'Retry build from last checkpoint',
          automaticRetry: true,
          manualIntervention: false,
          estimatedRecoveryTime: '5 minutes',
        }
      ],
      notes: 'Processes 1M+ documents per minute, incremental builds',
      assumptions: ['Updates are idempotent'],
      position: { x: 600, y: 1100 },
    },
    {
      id: 'update-queue',
      name: 'Update Queue',
      type: 'Queue',
      responsibility: 'Buffer document updates for batch processing',
      inputs: ['Document update events'],
      outputs: ['Batched updates for indexer'],
      dependencies: [],
      owner: 'Infrastructure Team',
      environment: 'prod',
      criticality: 'medium',
      failureModes: [],
      recoveryStrategy: [],
      notes: 'Kafka cluster with 7-day retention',
      assumptions: ['Peak load is 100k events/sec'],
      position: { x: 1000, y: 1100 },
    },
    {
      id: 'content-api',
      name: 'Content API',
      type: 'External',
      responsibility: 'External service that publishes content updates',
      inputs: [],
      outputs: ['Document update events'],
      dependencies: ['update-queue'],
      owner: 'Content Team',
      environment: 'prod',
      criticality: 'low',
      failureModes: [],
      recoveryStrategy: [],
      notes: 'External microservice, rate limited to 10k req/sec',
      assumptions: ['Content updates are non-critical path'],
      position: { x: 1400, y: 1100 },
    },
  ],
  connections: [
    // Load balancer to regional APIs
    {
      id: 'conn-lb-us',
      source: 'frontend-lb',
      target: 'regional-api-us',
      direction: 'unidirectional',
      contract: 'HTTPS/2 with connection pooling',
      assumptions: ['Network latency < 5ms'],
      failureBehavior: 'Route to next healthy region',
      retryPolicy: {
        enabled: true,
        maxRetries: 2,
        backoffStrategy: 'linear',
      },
      timeoutSeconds: 1,
      isControlFlow: false,
      isCriticalPath: true,
    },
    {
      id: 'conn-lb-eu',
      source: 'frontend-lb',
      target: 'regional-api-eu',
      direction: 'unidirectional',
      contract: 'HTTPS/2 with connection pooling',
      assumptions: ['Network latency < 5ms'],
      failureBehavior: 'Route to next healthy region',
      retryPolicy: {
        enabled: true,
        maxRetries: 2,
        backoffStrategy: 'linear',
      },
      timeoutSeconds: 1,
      isControlFlow: false,
      isCriticalPath: true,
    },
    {
      id: 'conn-lb-asia',
      source: 'frontend-lb',
      target: 'regional-api-asia',
      direction: 'unidirectional',
      contract: 'HTTPS/2 with connection pooling',
      assumptions: ['Network latency < 5ms'],
      failureBehavior: 'Route to next healthy region',
      retryPolicy: {
        enabled: true,
        maxRetries: 2,
        backoffStrategy: 'linear',
      },
      timeoutSeconds: 1,
      isControlFlow: false,
      isCriticalPath: true,
    },
    // US API to cache and index
    {
      id: 'conn-api-cache-us',
      source: 'regional-api-us',
      target: 'cache-us',
      direction: 'unidirectional',
      contract: 'Redis protocol with pipelining',
      assumptions: ['Cache hit rate > 70%'],
      failureBehavior: 'Skip cache, query index directly',
      timeoutSeconds: 0.01,
      isControlFlow: false,
      isCriticalPath: true,
    },
    {
      id: 'conn-api-index-us',
      source: 'regional-api-us',
      target: 'index-us',
      direction: 'unidirectional',
      contract: 'gRPC with protobuf serialization',
      assumptions: ['Index is always available'],
      failureBehavior: 'Return partial results or error',
      retryPolicy: {
        enabled: true,
        maxRetries: 1,
        backoffStrategy: 'linear',
      },
      timeoutSeconds: 0.05,
      isControlFlow: false,
      isCriticalPath: true,
    },
    // EU API to cache and index
    {
      id: 'conn-api-cache-eu',
      source: 'regional-api-eu',
      target: 'cache-eu',
      direction: 'unidirectional',
      contract: 'Redis protocol with pipelining',
      assumptions: ['Cache hit rate > 70%'],
      failureBehavior: 'Skip cache, query index directly',
      timeoutSeconds: 0.01,
      isControlFlow: false,
      isCriticalPath: true,
    },
    {
      id: 'conn-api-index-eu',
      source: 'regional-api-eu',
      target: 'index-eu',
      direction: 'unidirectional',
      contract: 'gRPC with protobuf serialization',
      assumptions: ['Index is always available'],
      failureBehavior: 'Return partial results or error',
      timeoutSeconds: 0.05,
      isControlFlow: false,
      isCriticalPath: true,
    },
    // Asia API to cache and index
    {
      id: 'conn-api-cache-asia',
      source: 'regional-api-asia',
      target: 'cache-asia',
      direction: 'unidirectional',
      contract: 'Redis protocol with pipelining',
      assumptions: ['Cache hit rate > 70%'],
      failureBehavior: 'Skip cache, query index directly',
      timeoutSeconds: 0.01,
      isControlFlow: false,
      isCriticalPath: true,
    },
    {
      id: 'conn-api-index-asia',
      source: 'regional-api-asia',
      target: 'index-asia',
      direction: 'unidirectional',
      contract: 'gRPC with protobuf serialization',
      assumptions: ['Index is always available'],
      failureBehavior: 'Return partial results or error',
      timeoutSeconds: 0.05,
      isControlFlow: false,
      isCriticalPath: true,
    },
    // Content API to queue
    {
      id: 'conn-content-queue',
      source: 'content-api',
      target: 'update-queue',
      direction: 'unidirectional',
      contract: 'Kafka producer API',
      assumptions: ['Queue is always available'],
      failureBehavior: 'Retry with exponential backoff',
      retryPolicy: {
        enabled: true,
        maxRetries: 10,
        backoffStrategy: 'exponential',
      },
      timeoutSeconds: 5,
      isControlFlow: false,
      isCriticalPath: false,
    },
    // Indexer to queue and indices
    {
      id: 'conn-indexer-queue',
      source: 'indexer',
      target: 'update-queue',
      direction: 'unidirectional',
      contract: 'Kafka consumer API with consumer groups',
      assumptions: ['Messages are ordered within partition'],
      failureBehavior: 'Reprocess from last committed offset',
      isControlFlow: false,
      isCriticalPath: false,
    },
    {
      id: 'conn-indexer-index-us',
      source: 'indexer',
      target: 'index-us',
      direction: 'unidirectional',
      contract: 'Bulk index update API',
      assumptions: ['Updates are atomic per shard'],
      failureBehavior: 'Rollback and retry',
      retryPolicy: {
        enabled: true,
        maxRetries: 3,
        backoffStrategy: 'exponential',
      },
      timeoutSeconds: 60,
      isControlFlow: false,
      isCriticalPath: false,
    },
    {
      id: 'conn-indexer-index-eu',
      source: 'indexer',
      target: 'index-eu',
      direction: 'unidirectional',
      contract: 'Bulk index update API',
      assumptions: ['Updates are atomic per shard'],
      failureBehavior: 'Rollback and retry',
      timeoutSeconds: 60,
      isControlFlow: false,
      isCriticalPath: false,
    },
    {
      id: 'conn-indexer-index-asia',
      source: 'indexer',
      target: 'index-asia',
      direction: 'unidirectional',
      contract: 'Bulk index update API',
      assumptions: ['Updates are atomic per shard'],
      failureBehavior: 'Rollback and retry',
      timeoutSeconds: 60,
      isControlFlow: false,
      isCriticalPath: false,
    },
  ],
  annotations: [],
  status: 'Valid',
  currentState: 'Normal',
  createdBy: userId,
  createdAt: new Date().toISOString(),
  updatedAt: new Date().toISOString(),
  version: 1,
  collaborators: [],
  isPublic: false,
});
